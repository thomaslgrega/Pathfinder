{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/astar.js","webpack:///./src/dijkstras.js","webpack:///./src/index.js","webpack:///./src/manhattanDistance.js","webpack:///./src/node.js","webpack:///./src/pathfinder.js","webpack:///./src/pythagoreanTheorem.js","webpack:///./src/recursiveDivision.js"],"names":["openNodes","visited","finalPath","aStarAlgorithm","nodes","start","end","forEach","row","node","isStart","isEnd","includes","isOpen","push","length","lowestIdx","currentNode","i","f","cameFrom","isPath","splice","connectedNodes","connectedNode","newG","g","betterPath","isWall","h","manhattanDistance","dijkstrasAlgorithm","neighbor","tentative","weight","prepareAStar","createNodes","animateAStar","done","requestId","requestAnimationFrame","cancelAnimationFrame","renderNodes","prepareDijkstras","animateDijkstras","clearBtn","document","getElementById","addEventListener","container","firstChild","removeChild","generateEmptyBoard","addMouseEnterEvent","addMouseLeaveEvent","handleRandomWalls","nodesArr","Array","from","querySelectorAll","classList","contains","Math","random","add","aStarBtn","dijkstrasBtn","randomWallsBtn","cols","rows","j","Node","grid","createWall","deleteWall","dragStartNode","dragEndNode","e","target","remove","checkNode","endNode","a","abs","b","distance","algo","Infinity","nodeRow","children","nodeDiv","newNode","findConnectedNodes","newRow","createElement","newDiv","isWeighted","appendChild","pythagoreanTheorem","c","sqrt","recursiveDivisionClosure","randomStartJ","floor","randomEndJ","wall","randomStartI","randomEndI","recursiveDivision","chambers","window"],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA,IAAIA,SAAS,GAAG,EAAhB;AACA,IAAIC,OAAO,GAAG,EAAd;AACA,IAAIC,SAAS,GAAG,EAAhB;;AAEA,IAAMC,cAAc,GAAG,SAAjBA,cAAiB,CAACC,KAAD,EAAW;AAChC,MAAIC,KAAJ;AACA,MAAIC,GAAJ,CAFgC,CAIhC;;AACAF,OAAK,CAACG,OAAN,CAAc,UAAAC,GAAG,EAAI;AACnBA,OAAG,CAACD,OAAJ,CAAY,UAAAE,IAAI,EAAI;AAClB,UAAIA,IAAI,CAACC,OAAT,EAAkB;AAChBL,aAAK,GAAGI,IAAR;AACD,OAFD,MAEO,IAAIA,IAAI,CAACE,KAAT,EAAgB;AACrBL,WAAG,GAAGG,IAAN;AACD;AACF,KAND;AAOD,GARD;;AAUA,MAAI,CAACR,OAAO,CAACW,QAAR,CAAiBP,KAAjB,CAAL,EAA8B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAL,aAAS,GAAG,EAAZ;AACAC,WAAO,GAAG,EAAV;AACAC,aAAS,GAAG,EAAZ;AACAG,SAAK,CAACQ,MAAN,GAAe,IAAf;AACAb,aAAS,CAACc,IAAV,CAAeT,KAAf;AACD;;AAED,MAAIL,SAAS,CAACe,MAAV,GAAmB,CAAvB,EAA0B;AACxB,QAAIC,SAAS,GAAG,CAAhB;AACA,QAAIC,WAAJ,CAFwB,CAGxB;;AACAjB,aAAS,CAACO,OAAV,CAAkB,UAACE,IAAD,EAAOS,CAAP,EAAa;AAC7B,UAAIT,IAAI,CAACU,CAAL,GAASnB,SAAS,CAACgB,SAAD,CAAT,CAAqBG,CAAlC,EAAqC;AACnCH,iBAAS,GAAGE,CAAZ;AACD;AACF,KAJD;AAMAD,eAAW,GAAGjB,SAAS,CAACgB,SAAD,CAAvB,CAVwB,CAWxB;;AACA,QAAIC,WAAW,KAAKX,GAApB,EAAyB;AACvBJ,eAAS,CAACY,IAAV,CAAeG,WAAf;;AACA,aAAOA,WAAW,CAACG,QAAnB,EAA6B;AAC3BH,mBAAW,CAACI,MAAZ,GAAqB,IAArB;AACAnB,iBAAS,CAACY,IAAV,CAAeG,WAAW,CAACG,QAA3B;AACAH,mBAAW,GAAGA,WAAW,CAACG,QAA1B;AACD;;AAED,aAAO,IAAP;AACD,KArBuB,CAuBxB;;;AACAH,eAAW,CAACJ,MAAZ,GAAqB,KAArB;AACAI,eAAW,CAAChB,OAAZ,GAAsB,IAAtB;AACAD,aAAS,CAACsB,MAAV,CAAiBN,SAAjB,EAA4B,CAA5B;AACAf,WAAO,CAACa,IAAR,CAAaG,WAAb,EA3BwB,CA4BxB;;AACAA,eAAW,CAACM,cAAZ,CAA2BhB,OAA3B,CAAmC,UAAAiB,aAAa,EAAI;AAClD,UAAIC,IAAI,GAAGR,WAAW,CAACS,CAAZ,GAAgB,CAA3B;AAEA,UAAIC,UAAU,GAAG,KAAjB;;AACA,UAAI,CAAC1B,OAAO,CAACW,QAAR,CAAiBY,aAAjB,CAAD,IAAoC,CAACA,aAAa,CAACI,MAAvD,EAA+D;AAC7D;AACA,YAAI5B,SAAS,CAACY,QAAV,CAAmBY,aAAnB,CAAJ,EAAuC;AACrC;AACA;AACA,cAAIC,IAAI,GAAGD,aAAa,CAACE,CAAzB,EAA4B;AAC1BF,yBAAa,CAACE,CAAd,GAAkBD,IAAlB;AACAE,sBAAU,GAAG,IAAb;AACD,WANoC,CAOrC;;AACD,SARD,MAQO;AACL;AACAA,oBAAU,GAAG,IAAb;AACAH,uBAAa,CAACE,CAAd,GAAkBD,IAAlB;AACAD,uBAAa,CAACX,MAAd,GAAuB,IAAvB;AACAb,mBAAS,CAACc,IAAV,CAAeU,aAAf;AACD,SAhB4D,CAkB7D;;;AACA,YAAIG,UAAJ,EAAgB;AACd;AACA;AAEA;AACAH,uBAAa,CAACK,CAAd,GAAkBC,kEAAiB,CAACN,aAAD,EAAgBlB,GAAhB,CAAnC,CALc,CAMd;;AACAkB,uBAAa,CAACL,CAAd,GAAkBK,aAAa,CAACE,CAAd,GAAkBF,aAAa,CAACK,CAAlD;AACAL,uBAAa,CAACJ,QAAd,GAAyBH,WAAzB;AACD;AACF;AACF,KAlCD;AAmCD,GAhED,MAgEO;AACL;AACA,WAAO,IAAP;AACD;AACF,CApGD;;AAsGed,6EAAf,E;;;;;;;;;;;;AC/GA;AAAA;AAEA,IAAIH,SAAS,GAAG,EAAhB;AACA,IAAIC,OAAO,GAAG,EAAd;AACA,IAAIC,SAAS,GAAG,EAAhB;;AAEA,IAAM6B,kBAAkB,GAAG,SAArBA,kBAAqB,CAAC3B,KAAD,EAAW;AACpC,MAAIC,KAAJ;AACA,MAAIC,GAAJ;AACA,MAAIW,WAAJ,CAHoC,CAKpC;;AACAb,OAAK,CAACG,OAAN,CAAc,UAAAC,GAAG,EAAI;AACnBA,OAAG,CAACD,OAAJ,CAAY,UAAAE,IAAI,EAAI;AAClB,UAAIA,IAAI,CAACC,OAAT,EAAkB;AAChBL,aAAK,GAAGI,IAAR;AACD,OAFD,MAEO,IAAIA,IAAI,CAACE,KAAT,EAAgB;AACrBL,WAAG,GAAGG,IAAN;AACD;AACF,KAND;AAOD,GARD;AAUAJ,OAAK,CAACqB,CAAN,GAAU,CAAV;;AAEA,MAAI,CAACzB,OAAO,CAACW,QAAR,CAAiBP,KAAjB,CAAL,EAA8B;AAC5BL,aAAS,GAAG,EAAZ;AACAC,WAAO,GAAG,EAAV;AACAC,aAAS,GAAG,EAAZ;AACAG,SAAK,CAACQ,MAAN,GAAe,IAAf;AACAb,aAAS,CAACc,IAAV,CAAeT,KAAf;AACAY,eAAW,GAAGZ,KAAd;AACD;;AAED,MAAIL,SAAS,CAACe,MAAV,GAAmB,CAAvB,EAA0B;AACxB,QAAIC,SAAS,GAAG,CAAhB;AACAC,eAAW,CAFa,CAGxB;;AACAjB,aAAS,CAACO,OAAV,CAAkB,UAACE,IAAD,EAAOS,CAAP,EAAa;AAC7B,UAAIT,IAAI,CAACiB,CAAL,GAAS1B,SAAS,CAACgB,SAAD,CAAT,CAAqBU,CAAlC,EAAqC;AACnCV,iBAAS,GAAGE,CAAZ;AACD;AACF,KAJD;AAMAD,eAAW,GAAGjB,SAAS,CAACgB,SAAD,CAAvB,CAVwB,CAWxB;;AACA,QAAIC,WAAW,KAAKX,GAApB,EAAyB;AACvBJ,eAAS,CAACY,IAAV,CAAeG,WAAf;;AACA,aAAOA,WAAW,CAACG,QAAnB,EAA6B;AAC3BH,mBAAW,CAACI,MAAZ,GAAqB,IAArB;AACAnB,iBAAS,CAACY,IAAV,CAAeG,WAAW,CAACG,QAA3B;AACAH,mBAAW,GAAGA,WAAW,CAACG,QAA1B;AACD;;AAED,aAAO,IAAP;AACD;;AAEDH,eAAW,CAACM,cAAZ,CAA2BhB,OAA3B,CAAmC,UAAAyB,QAAQ,EAAI;AAC7C;AACA;AACA,UAAI,CAAC/B,OAAO,CAACW,QAAR,CAAiBoB,QAAjB,CAAD,IAA+B,CAACA,QAAQ,CAACJ,MAA7C,EAAqD;AACnD,YAAMK,SAAS,GAAGhB,WAAW,CAACS,CAAZ,GAAgBM,QAAQ,CAACE,MAA3C;;AACA,YAAID,SAAS,GAAGD,QAAQ,CAACN,CAAzB,EAA4B;AAC1BM,kBAAQ,CAACN,CAAT,GAAaO,SAAb;AACAD,kBAAQ,CAACZ,QAAT,GAAoBH,WAApB;AACD;;AAEDe,gBAAQ,CAACnB,MAAT,GAAkB,IAAlB;;AACA,YAAI,CAACb,SAAS,CAACY,QAAV,CAAmBoB,QAAnB,CAAL,EAAmC;AACjChC,mBAAS,CAACc,IAAV,CAAekB,QAAf;AACD;AACF;AACF,KAfD;AAiBAf,eAAW,CAACJ,MAAZ,GAAqB,KAArB;AACAI,eAAW,CAAChB,OAAZ,GAAsB,IAAtB;AACAD,aAAS,CAACsB,MAAV,CAAiBN,SAAjB,EAA4B,CAA5B;AACAf,WAAO,CAACa,IAAR,CAAaG,WAAb;AAED,GA7CD,MA6CO;AACL;AACA,WAAO,IAAP;AACD;AACF,CA5ED;;AA8Eec,iFAAf,E;;;;;;;;;;;;ACpFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;CAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAMI,YAAY,GAAG,SAAfA,YAAe,GAAM;AACzB,MAAM/B,KAAK,GAAGgC,+DAAW,CAAC,IAAD,CAAzB;AACAC,cAAY,CAACjC,KAAD,CAAZ;AACD,CAHD;;AAKA,IAAMiC,YAAY,GAAG,SAAfA,YAAe,CAACjC,KAAD,EAAW;AAC9B,MAAIkC,IAAI,GAAGnC,sDAAc,CAACC,KAAD,CAAzB;AACA,MAAMmC,SAAS,GAAGC,qBAAqB,CAAC;AAAA,WAAMH,YAAY,CAACjC,KAAD,CAAlB;AAAA,GAAD,CAAvC;;AACA,MAAIkC,IAAJ,EAAU;AACRG,wBAAoB,CAACF,SAAD,CAApB;AACD;;AAEDG,iEAAW,CAACtC,KAAD,CAAX;AACD,CARD;;AAUA,IAAMuC,gBAAgB,GAAG,SAAnBA,gBAAmB,GAAM;AAC7B,MAAMvC,KAAK,GAAGgC,+DAAW,CAAC,WAAD,CAAzB;AACAQ,kBAAgB,CAACxC,KAAD,CAAhB;AACD,CAHD;;AAKA,IAAMwC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACxC,KAAD,EAAW;AAClC,MAAIkC,IAAI,GAAGP,0DAAkB,CAAC3B,KAAD,CAA7B;AACA,MAAMmC,SAAS,GAAGC,qBAAqB,CAAC;AAAA,WAAMI,gBAAgB,CAACxC,KAAD,CAAtB;AAAA,GAAD,CAAvC;;AACA,MAAIkC,IAAJ,EAAU;AACRG,wBAAoB,CAACF,SAAD,CAApB;AACD;;AAEDG,iEAAW,CAACtC,KAAD,CAAX;AACD,CARD;;AAUA,IAAMyC,QAAQ,GAAGC,QAAQ,CAACC,cAAT,CAAwB,OAAxB,CAAjB;AACAF,QAAQ,CAACG,gBAAT,CAA0B,OAA1B,EAAmC,YAAO;AACxC,MAAMC,SAAS,GAAGH,QAAQ,CAACC,cAAT,CAAwB,iBAAxB,CAAlB;;AACA,SAAOE,SAAS,CAACC,UAAjB,EAA6B;AAC3BD,aAAS,CAACE,WAAV,CAAsBF,SAAS,CAACC,UAAhC;AACD;;AAEDE,oBAAkB;AAClBC,oBAAkB;AAClBC,oBAAkB;AACnB,CATD;;AAWA,IAAMC,iBAAiB,GAAG,SAApBA,iBAAoB,GAAM;AAC9B,MAAMC,QAAQ,GAAGC,KAAK,CAACC,IAAN,CAAWZ,QAAQ,CAACa,gBAAT,CAA0B,OAA1B,CAAX,CAAjB;AACAH,UAAQ,CAACjD,OAAT,CAAiB,UAAAE,IAAI,EAAI;AACvB,QAAI,CAACA,IAAI,CAACmD,SAAL,CAAeC,QAAf,CAAwB,OAAxB,CAAD,IAAqC,CAACpD,IAAI,CAACmD,SAAL,CAAeC,QAAf,CAAwB,KAAxB,CAAtC,IAAwEC,IAAI,CAACC,MAAL,KAAgB,IAA5F,EAAkG;AAChGtD,UAAI,CAACmD,SAAL,CAAeI,GAAf,CAAmB,SAAnB;AACD;AACF,GAJD;AAKD,CAPD;;AASA,IAAMC,QAAQ,GAAGnB,QAAQ,CAACC,cAAT,CAAwB,YAAxB,CAAjB;AACAkB,QAAQ,CAACjB,gBAAT,CAA0B,OAA1B,EAAmCb,YAAnC;AAEA,IAAM+B,YAAY,GAAGpB,QAAQ,CAACC,cAAT,CAAwB,eAAxB,CAArB;AACAmB,YAAY,CAAClB,gBAAb,CAA8B,OAA9B,EAAuCL,gBAAvC;AAEA,IAAMwB,cAAc,GAAGrB,QAAQ,CAACC,cAAT,CAAwB,YAAxB,CAAvB;AACAoB,cAAc,CAACnB,gBAAf,CAAgC,OAAhC,EAAyCO,iBAAzC,E,CAEA;AACA;;AAEA,IAAMH,kBAAkB,GAAG,SAArBA,kBAAqB,GAAM;AAC/B,MAAMgB,IAAI,GAAG,EAAb;AACA,MAAMC,IAAI,GAAG,EAAb;AACA,MAAMjE,KAAK,GAAG,IAAIqD,KAAJ,CAAUW,IAAV,CAAd;;AACA,OAAK,IAAIlD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkD,IAApB,EAA0BlD,CAAC,EAA3B,EAA+B;AAC7Bd,SAAK,CAACc,CAAD,CAAL,GAAW,IAAIuC,KAAJ,CAAUY,IAAV,CAAX;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,IAApB,EAA0BC,CAAC,EAA3B,EAA+B;AAC7BlE,WAAK,CAACc,CAAD,CAAL,CAASoD,CAAT,IAAc,IAAIC,6CAAJ,CAASrD,CAAT,EAAYoD,CAAZ,CAAd;AACD;AACF,GAT8B,CAU/B;;;AACAlE,OAAK,CAAC,EAAD,CAAL,CAAU,EAAV,EAAcM,OAAd,GAAwB,IAAxB;AACAN,OAAK,CAAC,EAAD,CAAL,CAAU,EAAV,EAAcO,KAAd,GAAsB,IAAtB;AAEAP,OAAK,CAACG,OAAN,CAAc,UAAAC,GAAG,EAAI;AACnBA,OAAG,CAACD,OAAJ,CAAY,UAAAE,IAAI,EAAI;AAClBA,UAAI,CAACmB,MAAL,GAAc,KAAd;AACD,KAFD;AAGD,GAJD;AAMAc,iEAAW,CAACtC,KAAD,CAAX;AACD,CArBD;;AAuBAgD,kBAAkB;AAElB,IAAMoB,IAAI,GAAG1B,QAAQ,CAACC,cAAT,CAAwB,iBAAxB,CAAb;AACA,IAAI0B,UAAU,GAAG,KAAjB;AACA,IAAIC,UAAU,GAAG,KAAjB;AACA,IAAIC,aAAa,GAAG,KAApB;AACA,IAAIC,WAAW,GAAG,KAAlB;AAEAJ,IAAI,CAACxB,gBAAL,CAAsB,WAAtB,EAAmC,UAAC6B,CAAD,EAAO;AACxC,MAAIA,CAAC,CAACC,MAAF,CAASlB,SAAT,CAAmBC,QAAnB,CAA4B,OAA5B,CAAJ,EAA0C;AACxCc,iBAAa,GAAG,IAAhB;AACD,GAFD,MAEO,IAAIE,CAAC,CAACC,MAAF,CAASlB,SAAT,CAAmBC,QAAnB,CAA4B,KAA5B,CAAJ,EAAwC;AAC7Ce,eAAW,GAAG,IAAd;AACD,GAFM,MAEA,IAAIC,CAAC,CAACC,MAAF,CAASlB,SAAT,CAAmBC,QAAnB,CAA4B,SAA5B,CAAJ,EAA4C;AACjDa,cAAU,GAAG,IAAb;AACAG,KAAC,CAACC,MAAF,CAASlB,SAAT,CAAmBmB,MAAnB,CAA0B,SAA1B;AACD,GAHM,MAGA;AACLN,cAAU,GAAG,IAAb;;AACA,QAAI,CAACI,CAAC,CAACC,MAAF,CAASlB,SAAT,CAAmBC,QAAnB,CAA4B,OAA5B,CAAD,IAAyC,CAACgB,CAAC,CAACC,MAAF,CAASlB,SAAT,CAAmBC,QAAnB,CAA4B,KAA5B,CAA9C,EAAkF;AAChFgB,OAAC,CAACC,MAAF,CAASlB,SAAT,CAAmBI,GAAnB,CAAuB,SAAvB;AACD;AACF;AACF,CAdD;AAgBAQ,IAAI,CAACxB,gBAAL,CAAsB,SAAtB,EAAiC,YAAM;AACrC2B,eAAa,GAAG,KAAhB;AACAC,aAAW,GAAG,KAAd;AACAH,YAAU,GAAG,KAAb;AACAC,YAAU,GAAG,KAAb;AACD,CALD;AAOO,IAAMrB,kBAAkB,GAAG,SAArBA,kBAAqB,GAAM;AACtC,MAAMG,QAAQ,GAAGC,KAAK,CAACC,IAAN,CAAWZ,QAAQ,CAACa,gBAAT,CAA0B,OAA1B,CAAX,CAAjB;AACAH,UAAQ,CAACjD,OAAT,CAAiB,UAAAE,IAAI,EAAI;AACvBA,QAAI,CAACuC,gBAAL,CAAsB,YAAtB,EAAoC,UAAC6B,CAAD,EAAO;AACzC,UAAIJ,UAAJ,EAAgB;AACd,YAAK,CAACI,CAAC,CAACC,MAAF,CAASlB,SAAT,CAAmBC,QAAnB,CAA4B,OAA5B,CAAD,IAAyC,CAACgB,CAAC,CAACC,MAAF,CAASlB,SAAT,CAAmBC,QAAnB,CAA4B,KAA5B,CAA/C,EAAoF;AAClFgB,WAAC,CAACC,MAAF,CAASlB,SAAT,CAAmBI,GAAnB,CAAuB,SAAvB;AACD;AACF,OAJD,MAIO,IAAIU,UAAJ,EAAgB;AACrBG,SAAC,CAACC,MAAF,CAASlB,SAAT,CAAmBmB,MAAnB,CAA0B,SAA1B;AACD,OAFM,MAEA,IAAIJ,aAAJ,EAAmB;AACxBE,SAAC,CAACC,MAAF,CAASlB,SAAT,CAAmBI,GAAnB,CAAuB,OAAvB;AACAa,SAAC,CAACC,MAAF,CAASlB,SAAT,CAAmBmB,MAAnB,CAA0B,SAA1B;AACD,OAHM,MAGA,IAAIH,WAAJ,EAAiB;AACtBC,SAAC,CAACC,MAAF,CAASlB,SAAT,CAAmBI,GAAnB,CAAuB,KAAvB;AACAa,SAAC,CAACC,MAAF,CAASlB,SAAT,CAAmBmB,MAAnB,CAA0B,SAA1B;AACD;AACF,KAdD;AAeD,GAhBD;AAiBD,CAnBM;AAqBA,IAAMzB,kBAAkB,GAAG,SAArBA,kBAAqB,GAAM;AACtC,MAAME,QAAQ,GAAGC,KAAK,CAACC,IAAN,CAAWZ,QAAQ,CAACa,gBAAT,CAA0B,OAA1B,CAAX,CAAjB;AACAH,UAAQ,CAACjD,OAAT,CAAiB,UAAAE,IAAI,EAAI;AACvBA,QAAI,CAACuC,gBAAL,CAAsB,YAAtB,EAAoC,UAAC6B,CAAD,EAAO;AACzC,UAAIF,aAAJ,EAAmB;AACjBE,SAAC,CAACC,MAAF,CAASlB,SAAT,CAAmBmB,MAAnB,CAA0B,OAA1B;AACD,OAFD,MAEO,IAAIH,WAAJ,EAAiB;AACtBC,SAAC,CAACC,MAAF,CAASlB,SAAT,CAAmBmB,MAAnB,CAA0B,KAA1B;AACD;AACF,KAND;AAOD,GARD;AASD,CAXM;AAaPzB,kBAAkB;AAClBD,kBAAkB,G;;;;;;;;;;;;ACrLlB;AAAA,IAAMvB,iBAAiB,GAAG,SAApBA,iBAAoB,CAACkD,SAAD,EAAYC,OAAZ,EAAwB;AAChD,MAAMC,CAAC,GAAGpB,IAAI,CAACqB,GAAL,CAASH,SAAS,CAAC9D,CAAV,GAAc+D,OAAO,CAAC/D,CAA/B,CAAV;AACA,MAAMkE,CAAC,GAAGtB,IAAI,CAACqB,GAAL,CAASH,SAAS,CAACV,CAAV,GAAcW,OAAO,CAACX,CAA/B,CAAV;AACA,MAAMe,QAAQ,GAAGH,CAAC,GAAGE,CAArB;AACA,SAAOC,QAAP;AACD,CALD;;AAOevD,gFAAf,E;;;;;;;;;;;;;;;;;;;ICPMyC,I;AACJ,gBAAYrD,CAAZ,EAAeoD,CAAf,EAAkB5D,OAAlB,EAA2BC,KAA3B,EAAkCiB,MAAlC,EAA0C0D,IAA1C,EAAgD;AAAA;;AAC9C;AACA,SAAKpE,CAAL,GAASA,CAAT;AACA,SAAKoD,CAAL,GAASA,CAAT;AACA,SAAK5D,OAAL,GAAeA,OAAf;AACA,SAAKC,KAAL,GAAaA,KAAb,CAL8C,CAM9C;;AACA,QAAI2E,IAAI,KAAK,WAAb,EAA0B;AACxB,WAAK5D,CAAL,GAAS6D,QAAT;AACA,WAAKrD,MAAL,GAAc,CAAd,CAFwB,CAGxB;AACA;AACA;AACA;AACA;AACA;AACD,KATD,MASO;AACL,WAAKR,CAAL,GAAS,CAAT;AACD,KAlB6C,CAoB9C;;;AACA,SAAKG,CAAL,GAAS,CAAT,CArB8C,CAsB9C;;AACA,SAAKV,CAAL,GAAS,CAAT;AACA,SAAKN,MAAL,GAAc,KAAd;AACA,SAAKZ,OAAL,GAAe,KAAf;AACA,SAAKsB,cAAL,GAAsB,EAAtB;AACA,SAAKF,MAAL,GAAc,KAAd;AACA,SAAKO,MAAL,GAAcA,MAAd,CA5B8C,CA6B9C;AACA;AACA;AACA;AAEA;AACA;;AACA,SAAKR,QAAL;AACD;;;;uCAEkBhB,K,EAAO;AACxB;AACA,UAAI,KAAKc,CAAL,GAASd,KAAK,CAACW,MAAN,GAAe,CAA5B,EAA+B;AAC7B,aAAKQ,cAAL,CAAoBT,IAApB,CAAyBV,KAAK,CAAC,KAAKc,CAAL,GAAS,CAAV,CAAL,CAAkB,KAAKoD,CAAvB,CAAzB;AACD;;AAED,UAAI,KAAKpD,CAAL,GAAS,CAAb,EAAgB;AACd,aAAKK,cAAL,CAAoBT,IAApB,CAAyBV,KAAK,CAAC,KAAKc,CAAL,GAAS,CAAV,CAAL,CAAkB,KAAKoD,CAAvB,CAAzB;AACD;;AAED,UAAI,KAAKA,CAAL,GAASlE,KAAK,CAAC,CAAD,CAAL,CAASW,MAAT,GAAkB,CAA/B,EAAkC;AAChC,aAAKQ,cAAL,CAAoBT,IAApB,CAAyBV,KAAK,CAAC,KAAKc,CAAN,CAAL,CAAc,KAAKoD,CAAL,GAAS,CAAvB,CAAzB;AACD;;AAED,UAAI,KAAKA,CAAL,GAAS,CAAb,EAAgB;AACd,aAAK/C,cAAL,CAAoBT,IAApB,CAAyBV,KAAK,CAAC,KAAKc,CAAN,CAAL,CAAc,KAAKoD,CAAL,GAAS,CAAvB,CAAzB;AACD;AACF;;;;;;AAGYC,mEAAf,E;;;;;;;;;;;;AC5DA;AAAA;AAAA;AAAA;CAEA;;AACO,IAAMnC,WAAW,GAAG,SAAdA,WAAc,CAACkD,IAAD,EAAU;AACnC;AAEA,MAAMlF,KAAK,GAAG,EAAd;AACA,MAAMiE,IAAI,GAAGZ,KAAK,CAACC,IAAN,CAAWZ,QAAQ,CAACa,gBAAT,CAA0B,UAA1B,CAAX,CAAb;AACAU,MAAI,CAAC9D,OAAL,CAAa,UAACC,GAAD,EAAMU,CAAN,EAAY;AACvB,QAAMsE,OAAO,GAAG,EAAhB;AACA/B,SAAK,CAACC,IAAN,CAAWlD,GAAG,CAACiF,QAAf,EAAyBlF,OAAzB,CAAiC,UAACmF,OAAD,EAAUpB,CAAV,EAAgB;AAC/C,UAAM1C,MAAM,GAAG6B,KAAK,CAACC,IAAN,CAAWgC,OAAO,CAAC9B,SAAnB,EAA8BhD,QAA9B,CAAuC,SAAvC,CAAf;AACA,UAAMF,OAAO,GAAG+C,KAAK,CAACC,IAAN,CAAWgC,OAAO,CAAC9B,SAAnB,EAA8BhD,QAA9B,CAAuC,OAAvC,CAAhB;AACA,UAAMD,KAAK,GAAG8C,KAAK,CAACC,IAAN,CAAWgC,OAAO,CAAC9B,SAAnB,EAA8BhD,QAA9B,CAAuC,KAAvC,CAAd;AACA,UAAM+E,OAAO,GAAG,IAAIpB,6CAAJ,CAASrD,CAAT,EAAYoD,CAAZ,EAAe5D,OAAf,EAAwBC,KAAxB,EAA+BiB,MAA/B,EAAuC0D,IAAvC,CAAhB;AACAE,aAAO,CAAC1E,IAAR,CAAa6E,OAAb;AACD,KAND;AAOAvF,SAAK,CAACU,IAAN,CAAW0E,OAAX;AACD,GAVD,EALmC,CAiBnC;;AACApF,OAAK,CAACG,OAAN,CAAc,UAAAC,GAAG,EAAI;AACnBA,OAAG,CAACD,OAAJ,CAAY,UAAAE,IAAI,EAAI;AAClBA,UAAI,CAACmF,kBAAL,CAAwBxF,KAAxB;AACD,KAFD;AAGD,GAJD;AAMA,SAAOA,KAAP;AACD,CAzBM,C,CA2BP;AACA;;AACO,IAAMsC,WAAW,GAAG,SAAdA,WAAc,CAACtC,KAAD,EAAW;AACpC;AACA,MAAM6C,SAAS,GAAGH,QAAQ,CAACC,cAAT,CAAwB,iBAAxB,CAAlB;;AACA,SAAOE,SAAS,CAACC,UAAjB,EAA6B;AAC3BD,aAAS,CAACE,WAAV,CAAsBF,SAAS,CAACC,UAAhC;AACD;;AAED9C,OAAK,CAACG,OAAN,CAAc,UAAAC,GAAG,EAAI;AACnB,QAAIqF,MAAM,GAAG/C,QAAQ,CAACgD,aAAT,CAAuB,KAAvB,CAAb;AACAD,UAAM,CAACjC,SAAP,CAAiBI,GAAjB,CAAqB,SAArB;AACAxD,OAAG,CAACD,OAAJ,CAAY,UAAAE,IAAI,EAAI;AAClB,UAAIsF,MAAM,GAAGjD,QAAQ,CAACgD,aAAT,CAAuB,KAAvB,CAAb;AACAC,YAAM,CAACnC,SAAP,CAAiBI,GAAjB,CAAqB,MAArB,EAFkB,CAGlB;;AACA,UAAIvD,IAAI,CAACC,OAAT,EAAkB;AAChBqF,cAAM,CAACnC,SAAP,CAAiBI,GAAjB,CAAqB,OAArB;AACA+B,cAAM,CAACnC,SAAP,CAAiBI,GAAjB,CAAqB,MAArB;AACD,OAHD,MAGO,IAAIvD,IAAI,CAACE,KAAT,EAAgB;AACrBoF,cAAM,CAACnC,SAAP,CAAiBI,GAAjB,CAAqB,KAArB;AACD,OAFM,MAEA,IAAIvD,IAAI,CAACR,OAAT,EAAkB;AACvB8F,cAAM,CAACnC,SAAP,CAAiBI,GAAjB,CAAqB,SAArB;AACD,OAFM,MAEA,IAAIvD,IAAI,CAACI,MAAT,EAAiB;AACtBkF,cAAM,CAACnC,SAAP,CAAiBI,GAAjB,CAAqB,SAArB;AACD;;AAED,UAAIvD,IAAI,CAACmB,MAAT,EAAiB;AACfmE,cAAM,CAACnC,SAAP,CAAiBI,GAAjB,CAAqB,SAArB;AACD;;AAED,UAAIvD,IAAI,CAACuF,UAAT,EAAqB;AACnBD,cAAM,CAACnC,SAAP,CAAiBI,GAAjB,CAAqB,aAArB;AACD;;AAED,UAAIvD,IAAI,CAACY,MAAL,IAAe,CAACZ,IAAI,CAACE,KAArB,IAA8B,CAACF,IAAI,CAACC,OAAxC,EAAiD;AAC/CqF,cAAM,CAACnC,SAAP,CAAiBI,GAAjB,CAAqB,SAArB;AACD;;AAED6B,YAAM,CAACI,WAAP,CAAmBF,MAAnB;AACD,KA5BD;AA8BA9C,aAAS,CAACgD,WAAV,CAAsBJ,MAAtB;AACD,GAlCD;AAmCD,CA1CM,C;;;;;;;;;;;;AChCP;AAAA,IAAMK,kBAAkB,GAAG,SAArBA,kBAAqB,CAAClB,SAAD,EAAYC,OAAZ,EAAwB;AACjD,MAAMC,CAAC,GAAGpB,IAAI,CAACqB,GAAL,CAASH,SAAS,CAAC9D,CAAV,GAAc+D,OAAO,CAAC/D,CAA/B,CAAV;AACA,MAAMkE,CAAC,GAAGtB,IAAI,CAACqB,GAAL,CAASH,SAAS,CAACV,CAAV,GAAcW,OAAO,CAACX,CAA/B,CAAV;AACA,MAAM6B,CAAC,GAAGrC,IAAI,CAACsC,IAAL,CAAWlB,CAAC,GAAGA,CAAL,GAAWE,CAAC,GAAGA,CAAzB,CAAV;AACA,SAAOe,CAAP;AACD,CALD;;AAOeD,iFAAf,E;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;CAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAMG,wBAAwB,GAAG,SAA3BA,wBAA2B,CAAC7B,IAAD,EAAU;AACzC;AACA,MAAMvB,SAAS,GAAGH,QAAQ,CAACC,cAAT,CAAwB,iBAAxB,CAAlB;;AACA,SAAOE,SAAS,CAACC,UAAjB,EAA6B;AAC3BD,aAAS,CAACE,WAAV,CAAsBF,SAAS,CAACC,UAAhC;AACD,GALwC,CAOzC;;;AACA,MAAMkB,IAAI,GAAG,EAAb;AACA,MAAMC,IAAI,GAAG,EAAb;AACA,MAAMjE,KAAK,GAAG,IAAIqD,KAAJ,CAAUW,IAAV,CAAd;;AACA,OAAK,IAAIlD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkD,IAApB,EAA0BlD,CAAC,EAA3B,EAA+B;AAC7Bd,SAAK,CAACc,CAAD,CAAL,GAAW,IAAIuC,KAAJ,CAAUY,IAAV,CAAX;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,IAApB,EAA0BC,CAAC,EAA3B,EAA+B;AAC7BlE,WAAK,CAACc,CAAD,CAAL,CAASoD,CAAT,IAAc,IAAIC,6CAAJ,CAASrD,CAAT,EAAYoD,CAAZ,CAAd;;AACA,UAAIpD,CAAC,KAAK,CAAN,IAAWoD,CAAC,KAAK,CAAjB,IAAsBpD,CAAC,KAAKkD,IAAI,GAAG,CAAnC,IAAwCE,CAAC,KAAKD,IAAI,GAAG,CAAzD,EAA4D;AAC1DjE,aAAK,CAACc,CAAD,CAAL,CAASoD,CAAT,EAAY1C,MAAZ,GAAqB,IAArB;AACD;AACF;AACF,GAnBwC,CAqBzC;;;AACA,MAAIkC,IAAI,CAACC,MAAL,KAAgB,GAApB,EAAyB;AACvB,QAAMuC,YAAY,GAAGxC,IAAI,CAACyC,KAAL,CAAYzC,IAAI,CAACC,MAAL,KAAgB,EAA5B,CAArB;AACA,QAAMyC,UAAU,GAAG1C,IAAI,CAACyC,KAAL,CAAYzC,IAAI,CAACC,MAAL,KAAgB,EAA5B,CAAnB;AACA3D,SAAK,CAAC,CAAD,CAAL,CAASkG,YAAT,EAAuB5F,OAAvB,GAAiC,IAAjC;AACAN,SAAK,CAAC,CAAD,CAAL,CAASkG,YAAT,EAAuB1E,MAAvB,GAAgC,KAAhC;AACAxB,SAAK,CAAC,EAAD,CAAL,CAAUoG,UAAV,EAAsB7F,KAAtB,GAA8B,IAA9B;AACAP,SAAK,CAAC,EAAD,CAAL,CAAUoG,UAAV,EAAsBC,IAAtB,GAA6B,KAA7B;AACD,GAPD,MAOO;AACL,QAAMC,YAAY,GAAG5C,IAAI,CAACyC,KAAL,CAAYzC,IAAI,CAACC,MAAL,KAAgB,EAA5B,CAArB;AACA,QAAM4C,UAAU,GAAG7C,IAAI,CAACyC,KAAL,CAAYzC,IAAI,CAACC,MAAL,KAAgB,EAA5B,CAAnB;AACA3D,SAAK,CAACsG,YAAD,CAAL,CAAoB,CAApB,EAAuBhG,OAAvB,GAAiC,IAAjC;AACAN,SAAK,CAACsG,YAAD,CAAL,CAAoB,CAApB,EAAuB9E,MAAvB,GAAgC,KAAhC;AACAxB,SAAK,CAACuG,UAAD,CAAL,CAAkB,EAAlB,EAAsBhG,KAAtB,GAA8B,IAA9B;AACAP,SAAK,CAACuG,UAAD,CAAL,CAAkB,EAAlB,EAAsB/E,MAAtB,GAA+B,KAA/B;AACD;;AAEDc,iEAAW,CAACtC,KAAD,CAAX,CAtCyC,CAwCzC;AACA;AACD,CA1CD;;AA4CA,IAAMwG,iBAAiB,GAAG,SAApBA,iBAAoB,GAAM;AAC9B,MAAIC,QAAQ,CAAC9F,MAAT,KAAoB,CAAxB,EAA2B;AAE3B+F,QAAM,CAACtE,qBAAP,CAA6BoE,iBAA7B;AACD,CAJD;;AAMeP,uFAAf,E","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","// https://en.wikipedia.org/wiki/A*_search_algorithm#Pseudocode\n\nimport pythagoreanTheorem from \"./pythagoreanTheorem\";\nimport manhattanDistance from \"./manhattanDistance\";\n\nlet openNodes = [];\nlet visited = [];\nlet finalPath = []\n\nconst aStarAlgorithm = (nodes) => {\n  let start;\n  let end;\n\n  // search for the start and end nodes\n  nodes.forEach(row => {\n    row.forEach(node => {\n      if (node.isStart) {\n        start = node;\n      } else if (node.isEnd) {\n        end = node;\n      }\n    })\n  });\n\n  if (!visited.includes(start)) {\n    // nodes.forEach(row => {\n    //   row.forEach(node => {\n    //     if (node.isStart) {\n    //       start = node;\n    //     } else if (node.isEnd) {\n    //       end = node;\n    //     }\n    //   })\n    // });\n    openNodes = [];\n    visited = [];\n    finalPath = [];\n    start.isOpen = true;\n    openNodes.push(start);\n  }\n\n  if (openNodes.length > 0) {\n    let lowestIdx = 0;\n    let currentNode;\n    // loop through openNodes to find the lowest f to get next node to traverse \n    openNodes.forEach((node, i) => {\n      if (node.f < openNodes[lowestIdx].f) {\n        lowestIdx = i;\n      }\n    })\n\n    currentNode = openNodes[lowestIdx];\n    // if currentNode is end node, search is done so draw the resulting path\n    if (currentNode === end) {\n      finalPath.push(currentNode);\n      while (currentNode.cameFrom) {\n        currentNode.isPath = true;\n        finalPath.push(currentNode.cameFrom);\n        currentNode = currentNode.cameFrom;\n      }\n\n      return true;\n    }\n\n    // remove node from open Nodes list and add it to the visited nodes list\n    currentNode.isOpen = false;\n    currentNode.visited = true;\n    openNodes.splice(lowestIdx, 1);\n    visited.push(currentNode);\n    // check all connected nodes for their g, h and f\n    currentNode.connectedNodes.forEach(connectedNode => {\n      let newG = currentNode.g + 1;\n\n      let betterPath = false;\n      if (!visited.includes(connectedNode) && !connectedNode.isWall) {\n        // if neighbor is NOT in the visited nodes list but in the open nodes list\n        if (openNodes.includes(connectedNode)) {\n          // and the newG is less than the current g of the neighbor, replace it with the newG.\n          // meaning this new path to the neighbor is faster than previous route\n          if (newG < connectedNode.g) {\n            connectedNode.g = newG;\n            betterPath = true;\n          }\n          // if neighbor is NOT in the visited nodes list and NOT in the open nodes list\n        } else {\n          // assign the g to the newG because it shouldn't have one and add this node to openNodes list\n          betterPath = true\n          connectedNode.g = newG;\n          connectedNode.isOpen = true;\n          openNodes.push(connectedNode);\n        }\n\n        // only change the f if this is a better path than previously calculated\n        if (betterPath) {\n          // find heuristic value by using pythagorean theorem from the node to end node (if nodes can move diagonal)\n          // connectedNode.h = pythagoreanTheorem(connectedNode, end);\n  \n          // find heuristic value by using manhattanDistance (because nodes can't move diagonal)\n          connectedNode.h = manhattanDistance(connectedNode, end);\n          // Add heuristic and g value (how long it took to get to this node) to get f\n          connectedNode.f = connectedNode.g + connectedNode.h;\n          connectedNode.cameFrom = currentNode;\n        }\n      }\n    })\n  } else {\n    // there's no path so return true to stop the loop\n    return true;\n  }\n}\n\nexport default aStarAlgorithm;","// https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Algorithm\n\nlet openNodes = [];\nlet visited = [];\nlet finalPath = []\n\nconst dijkstrasAlgorithm = (nodes) => {\n  let start;\n  let end;\n  let currentNode;\n\n  // search for the start and end nodes\n  nodes.forEach(row => {\n    row.forEach(node => {\n      if (node.isStart) {\n        start = node;\n      } else if (node.isEnd) {\n        end = node;\n      }\n    })\n  });\n\n  start.g = 0;\n\n  if (!visited.includes(start)) {\n    openNodes = [];\n    visited = [];\n    finalPath = [];\n    start.isOpen = true;\n    openNodes.push(start);\n    currentNode = start;\n  }\n\n  if (openNodes.length > 0) {\n    let lowestIdx = 0;\n    currentNode;\n    // loop through openNodes to find the lowest g to get currentNode\n    openNodes.forEach((node, i) => {\n      if (node.g < openNodes[lowestIdx].g) {\n        lowestIdx = i;\n      }\n    })\n\n    currentNode = openNodes[lowestIdx];\n    // if currentNode is end node, search is done so draw the resulting path\n    if (currentNode === end) {\n      finalPath.push(currentNode);\n      while (currentNode.cameFrom) {\n        currentNode.isPath = true;\n        finalPath.push(currentNode.cameFrom);\n        currentNode = currentNode.cameFrom;\n      }\n\n      return true;\n    }\n\n    currentNode.connectedNodes.forEach(neighbor => {\n      // Add currentNode's g and the weight of the neighbor to check if tentative is \n      // less than the current neighbor's g. Replace if it is.\n      if (!visited.includes(neighbor) && !neighbor.isWall) {\n        const tentative = currentNode.g + neighbor.weight;\n        if (tentative < neighbor.g) {\n          neighbor.g = tentative;\n          neighbor.cameFrom = currentNode;\n        }\n        \n        neighbor.isOpen = true;\n        if (!openNodes.includes(neighbor)) {\n          openNodes.push(neighbor);\n        }\n      }\n    })\n\n    currentNode.isOpen = false;\n    currentNode.visited = true;\n    openNodes.splice(lowestIdx, 1);\n    visited.push(currentNode);\n\n  } else {\n    // there's no path so return true to stop the loop\n    return true;\n  }\n}\n\nexport default dijkstrasAlgorithm;","import { createNodes, renderNodes } from './pathfinder';\nimport Node from './node'\nimport aStarAlgorithm from \"./astar\";\nimport dijkstrasAlgorithm from \"./dijkstras\"\nimport recursiveDivisionClosure from \"./recursiveDivision\";\n\n// ************ Used to control animation speed. May use it in the future *************\n// let fpsInterval, done, timeStart, now, elapsed;\n\n// const startAnimateAStar = (fps) => {\n//   fpsInterval = 1000 / fps;\n//   timeStart = Date.now();\n//   animateAStar();\n// }\n\n// const animateAStar = () => {\n//   const requestId = requestAnimationFrame(animateAStar);\n//   now = Date.now();\n//   elapsed = now - timeStart;\n//   if (elapsed > fpsInterval) {\n//     done = aStarAlgorithm(nodes);\n//     if (done) {\n//       cancelAnimationFrame(requestId);\n//     }\n//   }\n//   renderNodes(nodes);\n// }\n// ************************************************************************************\n\nconst prepareAStar = () => {\n  const nodes = createNodes(\"a*\");\n  animateAStar(nodes);\n}\n\nconst animateAStar = (nodes) => {\n  let done = aStarAlgorithm(nodes);\n  const requestId = requestAnimationFrame(() => animateAStar(nodes));\n  if (done) {\n    cancelAnimationFrame(requestId)\n  }\n\n  renderNodes(nodes)\n}\n\nconst prepareDijkstras = () => {\n  const nodes = createNodes(\"dijkstras\");\n  animateDijkstras(nodes);\n}\n\nconst animateDijkstras = (nodes) => {\n  let done = dijkstrasAlgorithm(nodes);\n  const requestId = requestAnimationFrame(() => animateDijkstras(nodes));\n  if (done) {\n    cancelAnimationFrame(requestId)\n  }\n\n  renderNodes(nodes)\n}\n\nconst clearBtn = document.getElementById(\"clear\");\nclearBtn.addEventListener(\"click\", () =>  {\n  const container = document.getElementById('pathfinder-grid');\n  while (container.firstChild) {\n    container.removeChild(container.firstChild);\n  }\n\n  generateEmptyBoard();\n  addMouseEnterEvent();\n  addMouseLeaveEvent();\n});\n\nconst handleRandomWalls = () => {\n  const nodesArr = Array.from(document.querySelectorAll(\".node\"));\n  nodesArr.forEach(node => {\n    if (!node.classList.contains(\"start\") && !node.classList.contains(\"end\") && Math.random() < 0.25) {\n      node.classList.add('is-wall');\n    }\n  });\n}\n\nconst aStarBtn = document.getElementById(\"a-star-btn\");\naStarBtn.addEventListener(\"click\", prepareAStar);\n\nconst dijkstrasBtn = document.getElementById(\"dijkstras-btn\");\ndijkstrasBtn.addEventListener(\"click\", prepareDijkstras);\n\nconst randomWallsBtn = document.getElementById(\"random-btn\");\nrandomWallsBtn.addEventListener(\"click\", handleRandomWalls); \n\n// const recursiveDivision = document.getElementById(\"recursive-division\");\n// recursiveDivision.addEventListener(\"click\", () => recursiveDivisionClosure());\n\nconst generateEmptyBoard = () => {\n  const cols = 60;\n  const rows = 30;\n  const nodes = new Array(cols);\n  for (let i = 0; i < cols; i++) {\n    nodes[i] = new Array(rows);\n    for (let j = 0; j < rows; j++) {\n      nodes[i][j] = new Node(i, j);\n    }\n  }\n  // create default start and end nodes\n  nodes[14][14].isStart = true;\n  nodes[45][14].isEnd = true;\n  \n  nodes.forEach(row => {\n    row.forEach(node => {\n      node.isWall = false;\n    })\n  })\n\n  renderNodes(nodes);\n}\n\ngenerateEmptyBoard()\n\nconst grid = document.getElementById(\"pathfinder-grid\");\nlet createWall = false;\nlet deleteWall = false;\nlet dragStartNode = false;\nlet dragEndNode = false;\n\ngrid.addEventListener(\"mousedown\", (e) => { \n  if (e.target.classList.contains(\"start\")) {\n    dragStartNode = true;\n  } else if (e.target.classList.contains(\"end\")) {\n    dragEndNode = true;\n  } else if (e.target.classList.contains(\"is-wall\")) {\n    deleteWall = true;\n    e.target.classList.remove(\"is-wall\")\n  } else {\n    createWall = true;\n    if (!e.target.classList.contains(\"start\") && !e.target.classList.contains(\"end\")) {\n      e.target.classList.add(\"is-wall\")\n    }\n  }\n});\n\ngrid.addEventListener(\"mouseup\", () => { \n  dragStartNode = false;\n  dragEndNode = false;\n  createWall = false;\n  deleteWall = false;\n});\n\nexport const addMouseEnterEvent = () => {\n  const nodesArr = Array.from(document.querySelectorAll(\".node\"));\n  nodesArr.forEach(node => {\n    node.addEventListener(\"mouseenter\", (e) => {\n      if (createWall) {\n        if ((!e.target.classList.contains(\"start\") && !e.target.classList.contains(\"end\"))) {\n          e.target.classList.add('is-wall');\n        }\n      } else if (deleteWall) {\n        e.target.classList.remove('is-wall')\n      } else if (dragStartNode) {\n        e.target.classList.add('start');\n        e.target.classList.remove('is-wall');\n      } else if (dragEndNode) {\n        e.target.classList.add('end');\n        e.target.classList.remove('is-wall');\n      } \n    });\n  })\n}\n\nexport const addMouseLeaveEvent = () => {\n  const nodesArr = Array.from(document.querySelectorAll(\".node\"));\n  nodesArr.forEach(node => {\n    node.addEventListener(\"mouseleave\", (e) => {\n      if (dragStartNode) {\n        e.target.classList.remove('start');\n      } else if (dragEndNode) {\n        e.target.classList.remove('end');\n      }\n    });\n  })\n}\n\naddMouseLeaveEvent();\naddMouseEnterEvent();","const manhattanDistance = (checkNode, endNode) => {\n  const a = Math.abs(checkNode.i - endNode.i);\n  const b = Math.abs(checkNode.j - endNode.j);\n  const distance = a + b;\n  return distance;\n}\n\nexport default manhattanDistance;","class Node {\n  constructor(i, j, isStart, isEnd, isWall, algo) {\n    // i and j are the location they are in the grid\n    this.i = i;\n    this.j = j;\n    this.isStart = isStart;\n    this.isEnd = isEnd;\n    // \"distance\" from start to this node.\n    if (algo === \"dijkstras\") {\n      this.g = Infinity;\n      this.weight = 1;\n      // weighted dijkstras making some nodes \"cost\" more to move to\n      // this.isWeighted = false\n      // if (Math.random() < 0.15 && !this.isStart && !this.isEnd) {\n      //   this.isWeighted = true;\n      //   this.weight = 5;\n      // }\n    } else {\n      this.g = 0;\n    }\n\n    // heuristic - basically a guess of how far to the end node (straight shot distance to end node)\n    this.h = 0;\n    // the total of j and h (basically, the lowest h is the path that the algorithm will take)\n    this.f = 0;\n    this.isOpen = false;\n    this.visited = false;\n    this.connectedNodes = [];\n    this.isPath = false;\n    this.isWall = isWall;\n    // randomly determine if this node will be a wall\n    // if (Math.random() < 0.25 && !this.isStart && !this.isEnd) {\n    //   this.isWall = true;\n    // }\n\n    // the previous node that we got here from. Used to backtrack when we reach the end node to\n    // find the path\n    this.cameFrom;\n  }\n\n  findConnectedNodes(nodes) {\n    // don't add nodes if they're out of bounds\n    if (this.i < nodes.length - 1) {\n      this.connectedNodes.push(nodes[this.i + 1][this.j])\n    }\n\n    if (this.i > 0) {\n      this.connectedNodes.push(nodes[this.i - 1][this.j])\n    } \n\n    if (this.j < nodes[0].length - 1) {\n      this.connectedNodes.push(nodes[this.i][this.j + 1])\n    }\n\n    if (this.j > 0) {\n      this.connectedNodes.push(nodes[this.i][this.j - 1])\n    }\n  }\n}\n\nexport default Node;","import Node from \"./node\";\n\n// creates a 2D array full of Node objects\nexport const createNodes = (algo) => {\n  // randomly generate numbers to determine start and end Nodes\n\n  const nodes = [];\n  const rows = Array.from(document.querySelectorAll('.row-div'));\n  rows.forEach((row, i) => {\n    const nodeRow = [];\n    Array.from(row.children).forEach((nodeDiv, j) => {\n      const isWall = Array.from(nodeDiv.classList).includes('is-wall');\n      const isStart = Array.from(nodeDiv.classList).includes('start');\n      const isEnd = Array.from(nodeDiv.classList).includes('end');\n      const newNode = new Node(i, j, isStart, isEnd, isWall, algo)\n      nodeRow.push(newNode);\n    });\n    nodes.push(nodeRow);\n  })\n\n  // find the neighbors of each node\n  nodes.forEach(row => {\n    row.forEach(node => {\n      node.findConnectedNodes(nodes);\n    })\n  })\n\n  return nodes;\n}\n\n// iterate through the nodes and render nodes depending on their state\n// each row will be a div container that wraps nodes \nexport const renderNodes = (nodes) => {\n  // remove the old grid so it doesn't keep creating a bunch of grids. There might be a better way to do this?\n  const container = document.getElementById('pathfinder-grid');\n  while (container.firstChild) {\n    container.removeChild(container.firstChild);\n  }\n\n  nodes.forEach(row => {\n    let newRow = document.createElement(\"div\");\n    newRow.classList.add(\"row-div\")\n    row.forEach(node => {\n      let newDiv = document.createElement(\"div\");\n      newDiv.classList.add('node');\n      // if (node.isStart) {\n      if (node.isStart) {\n        newDiv.classList.add('start');\n        newDiv.classList.add('open');\n      } else if (node.isEnd) {\n        newDiv.classList.add('end');\n      } else if (node.visited) {\n        newDiv.classList.add('visited')\n      } else if (node.isOpen) {\n        newDiv.classList.add('is-open')\n      } \n\n      if (node.isWall) {\n        newDiv.classList.add('is-wall')\n      }\n\n      if (node.isWeighted) {\n        newDiv.classList.add('is-weighted')\n      }\n\n      if (node.isPath && !node.isEnd && !node.isStart) {\n        newDiv.classList.add('is-path')\n      }\n\n      newRow.appendChild(newDiv);\n    });\n\n    container.appendChild(newRow);\n  })\n}\n","const pythagoreanTheorem = (checkNode, endNode) => {\n  const a = Math.abs(checkNode.i - endNode.i);\n  const b = Math.abs(checkNode.j - endNode.j);\n  const c = Math.sqrt((a * a) + (b * b));\n  return c;\n}\n\nexport default pythagoreanTheorem;","import { renderNodes } from \"./pathfinder\";\nimport Node from \"./node\";\n\n// http://www.integral-domain.org/lwilliams/Applets/algorithms/recursivedivision.php\n\n// 1. make outside completely a wall\n//   a. choose two spots on outside to be a start and end node\n// 2. choose random area to divide (first area will be the whole board)\n// 3. divide by adding walls all the way from one wall to another  \n// 4. choose random spot along the wall to make a gap\n// 5. if there are divided areas that have height AND width > 1, repeat\n// 6. else end process\n\nconst recursiveDivisionClosure = (grid) => {\n  // clear grid \n  const container = document.getElementById('pathfinder-grid');\n  while (container.firstChild) {\n    container.removeChild(container.firstChild);\n  }\n  \n  // make new grid with outside wall\n  const cols = 60;\n  const rows = 30;\n  const nodes = new Array(cols);\n  for (let i = 0; i < cols; i++) {\n    nodes[i] = new Array(rows);\n    for (let j = 0; j < rows; j++) {\n      nodes[i][j] = new Node(i, j);\n      if (i === 0 || j === 0 || i === cols - 1 || j === rows - 1) {\n        nodes[i][j].isWall = true;\n      }\n    }\n  }\n\n  // create random start and end nodes at opposite sides\n  if (Math.random() < 0.5) {\n    const randomStartJ = Math.floor((Math.random() * 30));\n    const randomEndJ = Math.floor((Math.random() * 30));\n    nodes[0][randomStartJ].isStart = true;\n    nodes[0][randomStartJ].isWall = false;\n    nodes[59][randomEndJ].isEnd = true;\n    nodes[59][randomEndJ].wall = false;\n  } else {\n    const randomStartI = Math.floor((Math.random() * 60));\n    const randomEndI = Math.floor((Math.random() * 60));\n    nodes[randomStartI][0].isStart = true;\n    nodes[randomStartI][0].isWall = false;\n    nodes[randomEndI][29].isEnd = true;\n    nodes[randomEndI][29].isWall = false;\n  }\n\n  renderNodes(nodes);\n\n  // const chambers = [initialChamber];\n  // recursiveDivision();\n}\n\nconst recursiveDivision = () => {\n  if (chambers.length === 0) return;\n\n  window.requestAnimationFrame(recursiveDivision);\n}\n\nexport default recursiveDivisionClosure;"],"sourceRoot":""}